package thread;

/**
 * @Auther: ccy
 * @Date: 2020/8/17 - 08 - 17 - 20:13
 * @Description:
 * 实现多线程的时候,必须要继承Thread类,必须要重写run方法,实现核心逻辑,启动线程的时候,必须通过start方法进行调用
 * 每次运行相同的代码,出来的结果可能不一样,原因在于多线程谁先抢占资源无法进行人为控制
 * 程序线程和电脑线程的区别:电脑4核8线程:超线程技术,一个cpu只能做一个事情,通过超线程技术(硬件)模拟出来的能同时执行多个线程:让一个cpu同时执行两个线程,所以是4核8线程
 * 程序最终还是要在cpu内运行的,4个cpu意味着同时只能有4个程序在并行执行.发明超线程的实现,让一个cpu做两件事情,与程序的多线程没有关系,程序的执行最终还是靠cpu执行的(cpu核数越高,程序代码运行越快)
 * @version: 1.0
 *
 */
public class Thread$生命周期$线程同步汇总Demo extends Thread{
    @Override
    public void run() {
        //具体执行的代码逻辑
        for (int i=0;i<10;i++){
            System.out.println(Thread.currentThread().getName()+"--------"+i);
        }
    }

    /**
     * 一:线程的生命周期:
     * 1 新生状态:当创建好当前线程对象时,没有启动之前(调用start方法之前),该线程对象就是新生状态,处于新生状态的线程有自己的内存
     *            空间,但是没有获取到资源,例如:   ThreadDemo thread=new ThreadDemo()       RunnableDemo run=new RunnableDemo()
     *
     * 2 就绪状态:准备开始执行,并没有执行,表示调用start方法之后,当对应的线程创建完成,且调用start方法之后,所有的线程会添加到一个就绪队列中.
     *           就绪状态线程具备了运行条件,但是还没有分配到cpu,当系统选定一个等待执行的线程后,它就会从就绪状态进入执行状态,该动作成为"cpu调度"
     *
     * 3 运行状态:当当前进程获取到cpu资源之后,就绪队列中的所有线程会去抢占cpu资源,谁先抢到谁先执行,在执行的过程中叫做运行状态,运行状态的线程执行自己的
     *           run方法中代码,直到等待某资源而阻塞或完成任何而死亡,如果在给定的时间片内没有执行结束,就会被系统给换下来回到就绪状态
     *
     * 4 死亡状态:当运行中的线程正常执行完所有的代码逻辑或者因为异常情况导致程序结束叫做死亡状态
     *           进入死亡状态的方式:1 正常运行完成结束
     *                            2 人为中断执行,stop方法,线程被强制性终止
     *                            3 程序抛出未捕获的异常
     *
     * 5 阻塞状态:在程序运行过程中,发生某些异常情况(如执行了sleep方法,或等待I/O资源:[公司有500人,只有一台打印机(输出设备),同时有10份等着打印,只能等待] 等资源),导致当前线程无法顺利执行下去,将让出cpu并暂时停止自己运行,进入阻塞状态.
     *           只有进入阻塞状态的原因消除之后,(比如睡眠时间已到,或等待I/O设备空闲下来)所有的阻塞队列会再次进入到就绪状态中排队,随机抢占cpu资源,被系统选中后从原来停止的位置开始继续执行
     *           进入阻塞状态的方式:sleep方法:不会释放锁,sleep时别的线程也不可以访问锁定对象
     *                            wait等待io资源:
     *                            join方法(代码中执行的逻辑):当某个线程等待另一个线程执行结束后,才继续执行时,使调用该方法的线程在此之前执行完毕,也就是等待调用该方法的线程执行完毕后再往下继续执行
     *                            yield:让出cpu使用权,从运行态直接进入就绪态,让cpu重新挑选哪一个线程成进入运行状态
     *
     *注意:在多线程的时候,可以实现唤醒和等待的过程,但是唤醒和等待操作的对象不是thread类,而是我们设置的共享对象或者共享变量
     *
     * 二:多线程并发访问的时候,会出现数据安全问题:
     * 解决方法:
     *         1.同步代码块
     *         synchronized(共享资源,共享对象,需要是object的子类){
     *             具体执行的代码块
     *         }
     *         2.同步方法
     *         将核心的代码逻辑定义成一个方法,使用synchronized关键字进行修饰,此时不需要指定共享对象
     *
     * 三:需要同步的前提:
     *                 1 必须有两个或两个以上的线程
     *                 2 必须是多个线程使用同一资源
     *                 3 必须保证同步中只能有一个线程在运行
     * @param args
     */
    public static void main(String[] args) {
        Thread$生命周期$线程同步汇总Demo threadDemo=new Thread$生命周期$线程同步汇总Demo();//创建了当前线程对象,没有启动之前,就是新生状态(RunnableDemo runnableDemo=new RunnableDeml())
        threadDemo.start();
        for (int i = 0; i <5 ; i++) {
            System.out.println(Thread.currentThread().getName()+"=============="+i);
        }
    }
}
